# -*- coding: utf-8 -*-
"""Copia de Copia de Código Final - ANAIS

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10HYDoT_hoGq0cF0j8vFEnAEiYNtwz-U1
"""

import operator

!apt install libspatialindex-dev
!pip install osmnx


import pandas as pd
import networkx as nx
import osmnx as ox
import csv
import random
from geopy.distance import geodesic
import matplotlib.pyplot as plt

from google.colab import drive
drive.mount('/content/drive')

import collections
from openpyxl import load_workbook
import time

#1;1;6;-70.6051622;-33.4363544;20;17


#####POSICION VEHICULOS


pos = collections.defaultdict(dict)

with open("/content/drive/Shareddrives/Proyecto Opti dinámica/Proyecto/vehiculos.txt", "r") as datos:
    
  count = 0
  data = datos.readlines()[0:10]
  for linea in data:
    valores = []
    count +=1
    for x in linea.strip().split(";"):
      valores.append(float(x))
      pos[count] = valores

print(pos)

###GRAFO

restaurant = pd.read_csv('/content/drive/Shareddrives/Proyecto Opti dinámica/Proyecto/Instancias/Restaurants.csv')

#print(restaurant)

G = collections.defaultdict(dict)
NR = restaurant['ID'].tolist()
LatR = restaurant['Latitud'].tolist()
LonR = restaurant['Longitud'].tolist()
for ind in range(len(NR)):
  G['R'+str(ind+1)] = (LatR[ind],LonR[ind])
for p in range(10):
  G['NV'+str(p+1)] = (tuple(pos[p+1]))
print(G)

###DICCIONARIO DE VEHICULOS
Veh = collections.defaultdict(dict)
for i in range(10):
  Veh[i+1] = collections.defaultdict(dict)
  Veh[i+1]['ruta'] = [['NV'+str(i+1),0]]
  Veh[i+1]['asignados'] = set()
  for ind in range(len(NR)):
    Veh[i+1]['R'+ str(ind+1)] = 0




print(Veh)

###PEDIDOS

with open("/content/drive/Shareddrives/Proyecto Opti dinámica/Proyecto/180_0.txt", "r") as datos:
  Simulaciones = collections.defaultdict(dict)
  pedidos = []
  for linea in datos:
    datos1 = []
    for x in linea.strip().split(";"):
      datos1.append(x)
    #if datos1[0] == '1':
    pedidos.append(datos1)
    Simulaciones[datos1[0]]=[]




for s in range(1,101):
  for i in pedidos:
    if i[0] == str(s):
      #print('entra')
      Simulaciones[str(s)].append(i)

print(Simulaciones['1'])

####INFOMACION DE CADA PEDIDO

def info_pedido(escenario, n):
  pedido = Simulaciones[escenario][n-1]
  cliente = ('D'+(pedido[1]))
  info = collections.defaultdict(dict)
  restaurant = ('R'+(pedido[5]))
  coord_cliente = (float(pedido[4]),float(pedido[3]))
  tiempo_pedido = int(pedido[2])
  tiempo_rest = int(pedido[6])
  info[cliente]['coord'] = coord_cliente
  info[cliente]['rest'] = restaurant
  info[cliente]['tiempo'] = tiempo_pedido
  info[cliente]['tiempo_rest'] = tiempo_rest
    
  return info

def formar_y(Theta,num_orden,escenario):
  inalterable = tuple(map(tuple, Theta))
  #Theta = [[['D1',0],['R20',0]],[],[],[],[],[],[],[],[],[]]
  #orden = {'D1': {'coord': (-33.4363544, -70.6051622), 'rest': 'R20', 'tiempo': 6, 'tiempo_rest': 17}}
  orden = info_pedido(f'{escenario}',num_orden)
  #orden = {'D1': {'coord': (-33.4363544, -70.6051622), 'rest': 'R20', 'tiempo': 6, 'tiempo_rest': 17}}
  y = collections.defaultdict(dict)
  len_Theta = len(Theta)
  
  for theta in range(len_Theta):
    Theta_prueba = list(map(list, inalterable))
    key = list(orden)
    key1 = key[0]
    cambiado = Theta_prueba[theta]
    #print('cambiado', cambiado)
    theta_n = AssingOrder(cambiado,key1,orden[key1]['rest'])
    if theta_n[0][0] == 'NV'+str(theta+1):
      theta_n.pop(0)

    Theta_prueba[theta] = theta_n

    y[theta+1] = Theta_prueba
    
  return y

S = collections.defaultdict(dict)
D = collections.defaultdict(dict)
Theta = collections.defaultdict(dict)
V = range(1,11)
b = 0
#--------------------------------------------------------------------------------------------------------------------------------------------------
#LA SEPARACIÓN ES TODO LO QUE TIENE QUE VER CON LA HEURÍSTICA DE INSERCIÓN 
#theta_CI = [('R1', 65), ('D1', 80), ('R2', 0), ('D2', 0)]
#perturbado1 = 2 'pos donde se insertó R2'
#perturbado2 = 3 'pos donde se insertó D2'
def recalcular_perturbados(theta_CI, perturbado1, perturbado2, afecta_D):
    #print('theta_CI', theta_CI)
    if perturbado1 != None:
        tr = theta_CI[perturbado1-1][1]
        #print('tiempo en que se llega al antecesor del rest', tr)
        lat1 = G[theta_CI[perturbado1-1][0]][0]
        lon1 = G[theta_CI[perturbado1-1][0]][1]
        lat2 = G[theta_CI[perturbado1][0]][0]
        lon2 = G[theta_CI[perturbado1][0]][1]
        t = (((ox.distance.great_circle_vec(lat1, lon1, lat2, lon2)/1000)*1.4)/vel_veh)*60 
        #print('tiempo entre antecesor y rest', t)
        theta_CI[perturbado1][1] = round(tr + t ,2)
        #print('Debería actualizarse el tiempo en que se llega al rest', theta_CI)
        tr += t
        #print('ahora estamos en tiempo en que  se llega al rest', tr)
        lat3 = G[theta_CI[perturbado1+1][0]][0]
        lon3 = G[theta_CI[perturbado1+1][0]][1]
        t = (((ox.distance.great_circle_vec(lat2, lon2, lat3, lon3)/1000)*1.4)/vel_veh)*60 + afecta_D
        #print('tiempo entre rest y suc', t)
        #print('DEmora ', t- afecta_D)
        #print('DEmora incluyento afecta_D', t)
        ta = theta_CI[perturbado1+1][1]
        #print('Antes, en llegar al sucesor del rest se demoraba', ta)
        theta_CI[perturbado1+1][1] = round(tr+t,2)
        #print('Debería actualizarse el tiempo en que se llega al sucesor del rest', theta_CI)
        
        if perturbado1 != perturbado2 - 1:
          delta = (theta_CI[perturbado1+1][1]-ta)
          #print('delta', delta)
          for ix in range(perturbado1+2, perturbado2):
             theta_CI[ix][1] += delta
          #print('theta_CI arreglando tiempos entre despues del sucesor y antes de que se inserte el pedido, en caso raro afecta al pedido', theta_CI)
          #print('###############################################CASO NORMAL:')
          tr = theta_CI[perturbado2-1][1]
          #print('Estamos expandiendo segundo retraso, y estamos parados en el tiempo antes de la llegada al pedido nuevo', tr) 
          lat1 = G[theta_CI[perturbado2-1][0]][0]
          lon1 = G[theta_CI[perturbado2-1][0]][1]
          lat2 = G[theta_CI[perturbado2][0]][0]
          lon2 = G[theta_CI[perturbado2][0]][1]
          t = (((ox.distance.great_circle_vec(lat1, lon1, lat2, lon2)/1000)*1.4)/vel_veh)*60 
          #print('tiempo entre antecesor y pedido', t)
          theta_CI[perturbado2][1] = round(tr + t,2)
          #print('Debería actualizarse el tiempo en que se llega al pedido', theta_CI)
          if perturbado2 + 1 < len(theta_CI):
              tr += t
              #print('Estamos expnadiendo segundo retraso, y estamos parados en el tiempo de llegada al pedido nuevo', tr)
              lat3 = G[theta_CI[perturbado2+1][0]][0]
              lon3 = G[theta_CI[perturbado2+1][0]][1]
              t = (((ox.distance.great_circle_vec(lat2, lon2, lat3, lon3)/1000)*1.4)/vel_veh)*60
              #print('tiempo entre pedido y suc', t)
              ta = theta_CI[perturbado2+1][1]
              #print('Antes, en llegar al sucesor del pedido se demoraba', ta)
              theta_CI[perturbado2+1][1] = round(tr+t,2)
              #print('Debería actualizarse el tiempo en que se llega al sucesor del pedido', theta_CI)
              delta = (theta_CI[perturbado2+1][1]-ta)
              #print('delta', delta)
              for ixx in range(perturbado2+2, len(theta_CI)):
                  theta_CI[ixx][1] += delta
              #print('Se tuvo que haber terminado de expandir el retraso del pedido', theta_CI)


        if perturbado1 == perturbado2 - 1:
          #print('###############################################CASO RARO:')
          tr += t
          #print('Estamos parados en el tiempo de llegada al pedido nuevo que a su vez es el sucesor del rest', tr)
          if perturbado2 + 1 < len(theta_CI):
            lat3 = G[theta_CI[perturbado2+1][0]][0]
            lon3 = G[theta_CI[perturbado2+1][0]][1]
            t = (((ox.distance.great_circle_vec(lat2, lon2, lat3, lon3)/1000)*1.4)/vel_veh)*60
            theta_CI[perturbado2+1][1] = round(tr+t,2)
            #print('Debería actualizarse el tiempo en que se llega al sucesor del pedido', theta_CI)
            ta = theta_CI[perturbado1-1][1]
            #print('En llegar al antecesor del restaurant se demoraba', ta)
            #print('Ahora, en llegar al sucesor del pedido se demora', theta_CI[perturbado2+1][1])
            delta = (theta_CI[perturbado2+1][1]-ta)
            #print('delta', delta)
            for ixx in range(perturbado2+2, len(theta_CI)):
                theta_CI[ixx][1] += delta
            #print('Se tuvo que haber terminado de expandir el retraso del pedido y el restaurant', theta_CI)
    else:
      tr = theta_CI[perturbado2-1][1]
      #print('Estamos expandiendo segundo retraso, y estamos parados en el tiempo antes de la llegada al pedido nuevo', tr) 
      lat1 = G[theta_CI[perturbado2-1][0]][0]
      lon1 = G[theta_CI[perturbado2-1][0]][1]
      lat2 = G[theta_CI[perturbado2][0]][0]
      lon2 = G[theta_CI[perturbado2][0]][1]
      t = (((ox.distance.great_circle_vec(lat1, lon1, lat2, lon2)/1000)*1.4)/vel_veh)*60 
      #print('tiempo entre antecesor y pedido', t)
      theta_CI[perturbado2][1] = round(tr + t,2)
      #print('Debería actualizarse el tiempo en que se llega al pedido', theta_CI)
      if perturbado2 + 1 < len(theta_CI):
          tr += t
          #print('Estamos expnadiendo segundo retraso, y estamos parados en el tiempo de llegada al pedido nuevo', tr)
          lat3 = G[theta_CI[perturbado2+1][0]][0]
          lon3 = G[theta_CI[perturbado2+1][0]][1]
          t = (((ox.distance.great_circle_vec(lat2, lon2, lat3, lon3)/1000)*1.4)/vel_veh)*60
          #print('tiempo entre pedido y suc', t)
          ta = theta_CI[perturbado2+1][1]
          #print('Antes, en llegar al sucesor del pedido se demoraba', ta)
          theta_CI[perturbado2+1][1] = round(tr+t,2)
          #print('Debería actualizarse el tiempo en que se llega al sucesor del pedido', theta_CI)
          delta = (theta_CI[perturbado2+1][1]-ta)
          #print('delta', delta)
          for ixx in range(perturbado2+2, len(theta_CI)):
              theta_CI[ixx][1] += delta
          #print('Se tuvo que haber terminado de expandir el retraso del pedido', theta_CI)

       
    #print('final', theta_CI)    
    return(theta_CI)
    
#G = {'R1': (-33.4349197484481, -70.62654818150504), 'R2': (-33.42862332518676, -70.61018584932576),'D1':(-33.4363544,-70.6051622), 'D2': (-33.4426659,-70.6340303)} #0 y 15
#theta = [('R1',65),('D1',80)]
#Voy a insertar el Restaurant 2 para eso comparo con todas las tuplas el que quede más cerca
#Despues voy a insertar el Pedido 2 comparando el tiempo con todas las tuplas después de donde está insertado el restaurant asociado 
#Order 'D2'
#https://github.com/gboeing/osmnx/issues/71  --> Euclidian entrega en metros pero es sobre grafo proyectado
#Si usamos euclidian implementar grafo proyectado: https://stackoverflow.com/questions/63245142/transform-lat-long-coordinates-for-a-osmnx-projected-map
def AssingOrder(theta, D, R):
    #print('antes de insertar',theta)
    inalterable_theta = tuple(map(tuple, theta))
    theta_CI = list(map(list, inalterable_theta))
    #print('Theta_CI', theta_CI)
    lat_R = G[R][0]
    lon_R = G[R][1]
    lat_D = G[D][0]
    lon_D = G[D][1]
    tiempo_al_R = {}
    tiempo_al_D = {}
    agregados = [a[0] for a in theta_CI]
    #print('agregados', agregados)

    if R not in agregados:
        for tup in theta:
            lat = G[tup[0]][0]
            lon = G[tup[0]][1]
            t = (((ox.distance.great_circle_vec(lat_R, lon_R, lat, lon)/1000)*1.4)/vel_veh)*60
            pos = theta.index(tup)
            tiempo_al_R[pos] = t

        #Insertamos el Restaurant luego de la tupla más cercana
        min_pos = min(tiempo_al_R.items(), key=operator.itemgetter(1))[0]
        tsa = tiempo_al_R[min_pos]
        #print('tsa', tsa)
        if tsa <= 10:
          afecta_D = 10-tsa
          #print('afecta_D 1', afecta_D)
                 
        else:
          afecta_D = 0
          #print('afecta_D 2', afecta_D)
               
        perturbado = min_pos + 1
        theta_CI.insert(perturbado, [R, 0])
        indice = theta_CI.index([R,0])
        afecta_D += 4
        #print('afecta_D +4', afecta_D)
    else:
      #print('SE SUPONE QUE ESTA EN AGREGADOS', R)
      for w in theta_CI:
          #indice = len(theta_CI)+1  ###++++++++++
          #print('w in theta_CI', w)
          if w[0]==R:
            #print('w[0]==R', w[0])
            indice = theta_CI.index(w)
            break

      
      
      #np = Veh[Theta.index(theta)+1][R]+1  
      #######################3Está bien?
      #afecta_D = 2*np + 2 
      afecta_D = 4
     
    for ind in range(indice, len(theta_CI)):
        lat = G[theta_CI[ind][0]][0]
        lon = G[theta_CI[ind][0]][1]
        t = (((ox.distance.great_circle_vec(lat_D, lon_D, lat, lon)/1000)*1.4)/vel_veh)*60
        pos = ind
        tiempo_al_D[pos] = t
        
    #Insertamos el Pedido luego de la tupla más cercana y posterior al restaurant donde pide
    min_pos = min(tiempo_al_D.items(), key=operator.itemgetter(1))[0]
    theta_CI.insert(min_pos + 1, [D, 0])
    # Ya insertada la nueva orden se deben recalcular los tiempos perturbados con una función
    # Se debe restringir cuantos pedidos se esperan en un mismo retaurant no necesariamente en esta función
    #print('afecta D', afecta_D)
    if len(theta_CI) - len(theta) == 2:
        theta_CI = recalcular_perturbados(theta_CI, perturbado, min_pos+1, afecta_D)
    else: 
        theta_CI = recalcular_perturbados(theta_CI, None, min_pos+1, afecta_D)
    return theta_CI

#------------------------------------------------------------------------------------------------------------

import collections


###AHORA SE CALCULAN LOS COSTOS DETERMINISTICOS
###Para calcular los costos, necesito las ordenes por vehículo en cada y
#ordenes_asignadas = {1: [[('D2', 90), ('D1', 95)], []], 2: [[('D1', 80)], [('D2',80)]]}

def costo_det(deadline, y,D, b):
  costos = collections.defaultdict(dict)
  count = 0
  for y_val in y.values():
    count += 1
    valor = list()
    dif = 0
    for lista in y_val:
      for nodo in lista:
        if nodo[0] in D:
          diferencia = ((nodo[1]+b) - (D[nodo[0]] + deadline))
        #print('diferencia',diferencia)
          valor.append(max(0,diferencia))
        costos[count] = valor
  return costos

def costo_est(deadline, y_nuevo, D, costo_deterministico,b):
  dicc_e = collections.defaultdict(dict)
  slack = collections.defaultdict(dict)
  for rut, ruta3 in y_nuevo.items():
    lista_delay = list()
    costo_s = 0
    for ruta4 in ruta3:
      #print('Estamos recorriendo la ruta', ruta4)
      for ruta5 in ruta4:
        #print('Estamos recorriendo el nodo', ruta5)
        if ruta5[0] in D:
          costo_e = max(0, (ruta5[1]+b) - (D[ruta5[0]]+deadline)) 
          costo_s += -(ruta5[1]+b) + (D[ruta5[0]]+deadline)
          lista_delay.append(costo_e)
          dicc_e[rut] = lista_delay

        #print('costo_s agregado hasta que se analizo', ruta5[0], ':', costo_s)

      slack[rut] = costo_s
      #print('slak hasta el momento:', slack)

  

  for ii,jj in dicc_e.items():
    for it in range(len(jj)):
      dicc_e[ii][it] = dicc_e[ii][it]  - costo_deterministico[ii][it]
      

  return dicc_e, slack

def atrasar_camino(camino, atraso, indice_retraso):
  for c in range(indice_retraso, len(camino)):
    camino[c][1] += atraso
  return camino

def actualizar_estado(Theta,t_actual,D,es,li,D_betados, D_final, R_final):
  #print('Theta', Theta)
  inalterable_Theta = tuple(map(tuple, Theta))
  Theta_act = list(map(list, inalterable_Theta))
  D_list = list(D.keys()) 
  D_list.pop()
  

  for d in D_list:
    if d not in D_betados:
      #print('D_list:',D_list)
      #print('d', d)
      # ACTUALIZAR RETRASOS
      ipedido = info_pedido(f'{es}',int(d[1:len(d)]))
      t_rest = ipedido[d]['tiempo_rest']
      rest_ = ipedido[d]['rest']
      t_ped = ipedido[d]['tiempo']
      t_est_rest = 0
      indice_retraso = 0
      for v in Veh.keys():
        '''
        print('este es el contador v:',v)
        print('Veh asignados:',Veh[v]['asignados'])
        '''
        if str(d) in Veh[v]['asignados']:
          vehi = v
          camino = Veh[vehi]['ruta']
          break
        # else:
        #   camino = []
        # break

      for nodo in camino:
        #print('el camino es', camino, 'deberia estar', rest_)
        #print('este es el nodo que estamos revisando:',nodo, 'especificamente calzando:', nodo[0], 'con el rest')
        if nodo[0] == rest_:
          #print('este es el nodo que estamos revisando:',nodo)
          #print('este es el restaurante asociado: ' ,rest_)

          t_est_rest = nodo[1]
          #print('t_est_rest:', t_est_rest)
          indice_retraso = camino.index(nodo)+1
          #print('indice retraso:',indice_retraso)

          break

      if t_est_rest == 0:# and li!= 1:
          # print('t_est_rest:', R_final[vehi][rest_])
          t_est_rest = float(R_final[vehi][rest_])
          indice_retraso = 0

      # if li ==1:
      #   #print('Se ajusta al tiempo del pedido 1, ya que estamos en li:', li)
      #   t_est_rest += t_ped
      #   #print('Se está revisando actualizacion D1 y tiempo planeado al rest:', t_est_rest ,'y el tiempo del pedido es:', t_ped)
      #   Theta_act[0][0][1] = t_est_rest
      #   Theta_act[0][1][1] = Theta_act[0][1][1]+t_ped


      atraso = t_rest - t_est_rest
      # print('El atraso que se produjo al actualizar estado fue de:',t_rest, '-', t_est_rest, '=', atraso)

      if atraso > 0:
        D_betados.append(d)
        camino = atrasar_camino(camino, atraso, indice_retraso)
        #print('camino atrasado', camino)

    
  #ACTUALIZAR LO QUE YA SE REALIZÓ
  
  for cam in Theta_act:
    # cam = [(),(),()]
    lis_ind = []
    for nod in cam:
      #print('nod', nod)
      #OJO
      if nod[1] <= t_actual:
        lis_ind.append(nod)
        if nod[0][0] == 'D': 
          #print('Durante los eventos se visitó:', nod[0], 'Se elimino de D y se agrego a D_final con su tiempo de cumplido')
          del D[nod[0]]
          D_final[nod[0]]=nod[1]

    #break
    vehic = Theta_act.index(cam)+1
    for z in lis_ind:
      #print('Del camino:', cam, 'se eliminará:', z)
      if z[0][0] == 'R':
        R_final[vehic][z[0]] = z[1]
      cam.remove(z)
      if len(cam) == 0 and z[0][0]!= 'N':
        #print('cam quedo sin elementos', cam)
        ultimo_visitado = z[0]
        #print('ultimo visitado', z[0])
        coord_ultimo = G[ultimo_visitado]
        G['NV'+str(vehic)]=coord_ultimo
        #print('VEhiculo', vehic, 'tubo que cambiar sus coordenada en G a:', coord_ultimo)
      #if eliminado[0] == 'D':
      #    D_final[eliminado] = []

  for car in Veh.keys():
    if len(Theta_act[car-1]) == 0:
      #ACTUALIZAR COORDENADAS OJOO
      Theta_act[car-1]= [['NV'+str(car), t_actual]]
      Veh[car]['ruta'] = [['NV'+str(car), t_actual]]

 
    
  #print('Veh', Veh)
  #print('Theta final', Theta_act)
  return Theta_act, D, Veh, D_final, D_betados, R_final

import copy
def creacion_futuro(y,t_simulado,D,es,sd):
  #print('y ANTES',y)
  #print('Theta', Theta)
  y_list = list(y.items())
  inalterable_y = tuple(map(tuple, y_list))
  y_act = list(map(list, inalterable_y))
  y_dict = dict(y_act)
  D_list = list(D.keys()) 

  for d in D_list:
    #print('ESTAMOS REVISANDO EL PEDIDO:', d)
    ruta_alt = collections.defaultdict(dict)
    #print('d', d)
    # ACTUALIZAR RETRASOS
    ipedido = info_pedido(f'{es}',int(d[1:len(d)]))
    #t_rest = ipedido[d]['tiempo_rest']
    rest_ = ipedido[d]['rest']
    t_ped = ipedido[d]['tiempo']
    mean = 10
    t_rest = np.random.gamma(shape = (mean/sd)**2, scale = 1/(mean/(sd**2)))
    
    # print('El tiempo simulado futuro fue:', t_rest, 'para el restaurant:', rest_, 'asociado al pedido:', d)
    #print('t_rest',t_rest)
    # print('este es el y_dict1:',y_dict[1])
    # print('este es el y_dict2:',y_dict[2])
    # print('este es el y_dict3:',y_dict[3])
    # print('este es el y_dict4:',y_dict[4])
    # print('este es el y_dict5:',y_dict[5])
    # print('este es el y_dict6:',y_dict[6])
    # print('este es el y_dict7:',y_dict[7])
    # print('este es el y_dict8:',y_dict[8])
    # print('este es el y_dict9:',y_dict[9])
    # print('este es el y_dict19:',y_dict[10])
    
    
#####-------escoger ruta a modificar
    
    for k, rutas_ in y_dict.items():
      for ruta1 in rutas_:
        for ruta2 in ruta1:
          if ruta2[0] == d:
            ruta_alt[k] = rutas_.index(ruta1)
    
    
    #print('ruta alterada',ruta_alt)
    for yy in ruta_alt.keys():
      #print(colored(('vamos en yy de ruta_alt',yy), 'yellow'))
      indice_retraso = []
      camino = copy.deepcopy(y_dict[yy][ruta_alt[yy]])  
      #print('+++++++el camino que estamos tomando es:' ,camino)
      for cami in camino:
        if cami[0] == rest_:
          #print('+++++cami', cami)
          t_est_rest = cami[1]
          #print('ENTRA+++++++',d)
          indice_retraso.append(camino.index(cami)+1)
          break

      retraso = t_rest - 10
      #print('el retraso es:', retraso)
      #print('retraso',retraso)

      if retraso > 0 and len(indice_retraso)>0:
        #print('ind retraso', indice_retraso)
        ind_ret = indice_retraso[0]
        camino = atrasar_camino(camino, retraso, ind_ret)
        #print('Se va a actualizar en:', y_dict[yy][ruta_alt[yy]])
        y_dict[yy][ruta_alt[yy]] = camino   
      
      # print('este es el y_dict1 actualizado:', y_dict[1])
      # print('este es el y_dict2 actualizado:', y_dict[2])
      # print('este es el y_dict3 actualizado:', y_dict[3])
      # print('este es el y_dict4 actualizado:', y_dict[4])
      # print('este es el y_dict5 actualizado:', y_dict[5])
      # print('este es el y_dict6 actualizado:', y_dict[6])
      # print('este es el y_dict7 actualizado:', y_dict[7])
      # print('este es el y_dict8 actualizado:', y_dict[8])
      # print('este es el y_dict9 actualizado:', y_dict[9])
      # print('este es el y_dict10 actualizado:', y_dict[10])
      

  #print('y DESPUES',y)
  return y_dict

import numpy as np
import random
from termcolor import colored

#x = []
#g = []
MIOPE = False


#x.append(b)
deadline = 30
vel_veh = 20
#b = 0
t_R = 10
sd = 1
sk = 11.669
n_veh = 10
T = []
buffer = []
#SIMULACION
for b in range(0,20):
  for es in range(1, 100):
    ###DICCIONARIO DE VEHICULOS
    Veh = collections.defaultdict(dict)
    for i in range(n_veh):
      Veh[i+1] = collections.defaultdict(dict)
      Veh[i+1]['ruta'] = [['NV'+str(i+1),0]]
      Veh[i+1]['asignados'] = set()
      for ind in range(len(NR)):
        Veh[i+1]['R'+ str(ind+1)] = 0

    D_betados = []
    # print(colored(('####################################################ESCENARIO:', es, '####################################################################'), 'green'))
    Theta = list()
    D = collections.defaultdict(dict) 
    D_inicial = collections.defaultdict(dict)
    D_final = collections.defaultdict(dict)
    R_final = collections.defaultdict(dict)


    for i in range(len(Veh)):
      Theta.append([['NV'+str(i+1),0]])

    for w in range(len(Veh)):
      R_final[w+1] = collections.defaultdict(dict)

    ######Asignamos la primera orden
    ######Llamamos a assign order y le pasamos theta al cual le vamos a asignar y el string de la orden y el del restaurant

    # ord = list(orden1)
    # #print(ord[0])
    # #print(orden1[ord[0]]['rest'])
    # A=0      #asignado
    # ruta = Theta[A]
    # orden = ord[0]
    # rest = orden1[ord[0]]['rest']
    # D[orden]= orden1[ord[0]]['tiempo']
    # D_inicial[orden]= orden1[ord[0]]['tiempo']
    # ##########AGREGAR SIEMPRE ANTES LA NUEVA ORDEN AL GRAFO
    # G[orden] = orden1[ord[0]]['coord']


    # theta_nuevo = AssingOrder(ruta,orden,rest)
    # if theta_nuevo[0][0] == 'NV'+str(A+1):
    #   theta_nuevo.pop(0)
    # #print(theta_nuevo)

    # Theta[A] = theta_nuevo
    # Veh[A+1][rest]=1
    #pospuestos = [['D3',50],['D5',60]]
    pospuestos = []
    # Veh[A+1]['asignados'].add(orden)
    # Veh[A+1]['ruta'] = theta_nuevo

    #------------------------------------------------------------------------------------------------------------------
    tiempo_inicio = orden1[ord[0]]['tiempo']

    for li in range(0,len(Simulaciones[f'{es}'])):
      num_orden = li+1
      #print(colored(('**************************************************************************************num_orden - li:',num_orden, '-', li, '**************************************************************************************'), 'blue'))
      t_prox_pedido = Simulaciones[f'{es}'][li][2]
      #print('el tiempo asociado a la orden es:',t_prox_pedido)
      if len(pospuestos) != 0:
        if pospuestos[0][1] < t_prox_pedido:
          t_actual = pospuestos[0][1]
          orden_actual = pospuestos[0][0]
        else:
          t_actual = t_prox_pedido
          orden_actual = 'D'+str(Simulaciones[f'{es}'][li][1])
          info = info_pedido(f'{es}',num_orden)
          G[orden_actual] = info[orden_actual]['coord']
          D[orden_actual]= info[orden_actual]['tiempo']
          D_inicial[orden_actual]= info[orden_actual]['tiempo']
      else:
        t_actual = int(t_prox_pedido)
        orden_actual = 'D'+str(Simulaciones[f'{es}'][li][1])
        #print('esta orden debe asociarse a num_orden',orden_actual)
        #print('Para el escenario:', es)
        info = info_pedido(f'{es}',num_orden)
        #print('La info de este pedido es:', info)
        G[orden_actual] = info[orden_actual]['coord']
        D[orden_actual]= info[orden_actual]['tiempo']
        D_inicial[orden_actual]= info[orden_actual]['tiempo'] #Este es para comparar despues con el tiempo real de la entrega del pedido
      #funcion que nos actualice lo que realmente pasó y retrase plan la cantidad de tiempo que realmente demoró el restaurant --> THETA ACTUALIZADO
      
      #print('Theta ANTES',Theta)
      
      # print('Veh1 ANTES',Veh[1])
      # print('Veh2 ANTES',Veh[2])
      # print('Veh3 ANTES',Veh[3])
      # print('Veh4 ANTES',Veh[4])
      # print('Veh5 ANTES',Veh[5])
      # print('Veh6 ANTES',Veh[6])
      # print('Veh7 ANTES',Veh[7])
      # print('Veh8 ANTES',Veh[8])
      # print('Veh9 ANTES',Veh[9])
      # print('Veh10 ANTES',Veh[10])
      # print('D ANTES',D)
      # print('D_final ANTES',D_final)
      # print('D_betados ANTES',D_betados)
      
      Theta, D, Veh, D_final, D_betados, R_final = actualizar_estado(Theta,t_actual,D,es, li, D_betados, D_final, R_final)
      
      # print('##########################DESDE AHORA EN ADELANTE EL ESTADO ESTÁ ACUTALIZADO#######################################')
      # print('Theta DESPUES',Theta)
      # print('Veh1 DESPUES',Veh[1])
      # print('Veh2 DESPUES',Veh[2])
      # print('Veh3 DESPUES',Veh[3])
      # print('Veh4 DESPUES',Veh[4])
      # print('Veh5 DESPUES',Veh[5])
      # print('Veh6 DESPUES',Veh[6])
      # print('Veh7 DESPUES',Veh[7])
      # print('Veh8 DESPUES',Veh[8])
      # print('Veh9 DESPUES',Veh[9])
      # print('Veh10 DESPUES',Veh[10])
      # print('D DESPUES',D)
      # print('D_final DESPUES',D_final)
      # print('D_betados DESPUES',D_betados)
      

      #print('Theta DESPUES',Theta)
      y = formar_y(Theta,num_orden,es)
      
      # print('y1', y[1])
      # print('y2', y[2])
      # print('y3', y[3])
      # print('y4', y[4])
      # print('y5', y[5])
      # print('y6', y[6])
      # print('y7', y[7])
      # print('y8', y[8])
      # print('y9', y[9])
      # print('y10', y[10])
      
      #Calculamos el costo determinístico una vez que obtenemos los estados postdecisión 'y'
      costodet = costo_det(deadline, y,D, b)
      #print('costo det',costodet)

      tiempo_entre_pedidos = np.random.exponential(scale=sk)
      #print('tiempo_entre_pedidos',tiempo_entre_pedidos)
      t_simulado = t_actual + tiempo_entre_pedidos
      #print('t_simulado',t_simulado)
      
      y_predecf = creacion_futuro(y,t_simulado,D,es,sd)
      
      # print('y_predecf1',y_predecf[1])
      # print('y_predecf2',y_predecf[2])
      # print('y_predecf3',y_predecf[3])
      # print('y_predecf4',y_predecf[4])
      # print('y_predecf5',y_predecf[5])
      # print('y_predecf6',y_predecf[6])
      # print('y_predecf7',y_predecf[7])
      # print('y_predecf8',y_predecf[8])
      # print('y_predecf9',y_predecf[9])
      # print('y_predecf10',y_predecf[10])
      
      costoest, slack = costo_est(deadline,y_predecf,D,costodet,b)
      #print('costo estocastico',costoest)
      #print('slack',slack)
      
      costo_total = []

      for cost in costoest.keys():
        costo_total.append(sum(costoest[cost]) + sum(costodet[cost]))
      
      veh_escogido = costo_total.index(min(costo_total))+1
      if sum(costo_total) == 0:
        veh_escogido = max(slack.items(), key=operator.itemgetter(1))[0]
      #print('veh_escogido y costo total',  veh_escogido, '------------',costo_total)

      if MIOPE == True:
        costo_total = []
        for cost in costodet.keys():
          costo_total.append(sum(costodet[cost]))
        veh_escogido = costo_total.index(min(costo_total))+1
        #print('veh_escogido_miope y costo total_miope',  veh_escogido, '------------',costo_total)

      R = info[orden_actual]['rest']
      theta_nuevo =  AssingOrder(Theta[veh_escogido-1],orden_actual,R)
      #print('La ruta del vehiculo escogido queda:', theta_nuevo)
      if theta_nuevo[0][0] == 'NV'+str(veh_escogido):
        theta_nuevo.pop(0)
      Theta[veh_escogido-1] =theta_nuevo
      #print('Theta con la ruta alterada del vehiculo escogido:', Theta)


      for th in Theta:
        Veh[Theta.index(th)+1]['ruta'] = Theta[Theta.index(th)]

      Veh[veh_escogido][R] +=1
      Veh[veh_escogido]['asignados'].add(orden_actual)
      
      # print('Veh1 DESPUES DE ASIGNAR',Veh[1])
      # print('Veh2 DESPUES DE ASIGNAR',Veh[2])
      # print('Veh3 DESPUES DE ASIGNAR',Veh[3])
      # print('Veh4 DESPUES DE ASIGNAR',Veh[4])
      # print('Veh5 DESPUES DE ASIGNAR',Veh[5])
      # print('Veh6 DESPUES DE ASIGNAR',Veh[6])
      # print('Veh7 DESPUES DE ASIGNAR',Veh[7])
      # print('Veh8 DESPUES DE ASIGNAR',Veh[8])
      # print('Veh9 DESPUES DE ASIGNAR',Veh[9])
      # print('Veh10 DESPUES DE ASIGNAR',Veh[10])
      

      #if li == 7:
      # break

    # print(colored(('**************************************************************************************LLEGO FINAL DEL DÍA:',540, 'MINUTOS**************************************************************************************'), 'blue'))
    t_actual = 540
    #funcion que nos actualice lo que realmente pasó y retrase plan la cantidad de tiempo que realmente demoró el restaurant --> THETA ACTUALIZADO
    
    # print('Theta ANTES',Theta)
    # print('Veh1 ANTES',Veh[1])
    # print('Veh2 ANTES',Veh[2])
    # print('Veh3 ANTES',Veh[3])
    # print('Veh4 ANTES',Veh[4])
    # print('Veh5 ANTES',Veh[5])
    # print('Veh6 ANTES',Veh[6])
    # print('Veh7 ANTES',Veh[7])
    # print('Veh8 ANTES',Veh[8])
    # print('Veh9 ANTES',Veh[9])
    # print('Veh10 ANTES',Veh[10])
    # print('D ANTES',D)
    # print('D_final ANTES',D_final)
    # print('D_betados ANTES',D_betados)
    
    Theta, D, Veh, D_final, D_betados, R_final = actualizar_estado(Theta,t_actual,D,es, li, D_betados, D_final, R_final)
    
    # print('##########################DESDE AHORA EN ADELANTE EL ESTADO ESTÁ ACUTALIZADO#######################################')
    # print('Theta DESPUES',Theta)
    # print('Veh1 DESPUES',Veh[1])
    # print('Veh2 DESPUES',Veh[2])
    # print('Veh3 DESPUES',Veh[3])
    # print('Veh4 DESPUES',Veh[4])
    # print('Veh5 DESPUES',Veh[5])
    # print('Veh6 DESPUES',Veh[6])
    # print('Veh7 DESPUES',Veh[7])
    # print('Veh8 DESPUES',Veh[8])
    # print('Veh9 DESPUES',Veh[9])
    # print('Veh10 DESPUES',Veh[10])
    # print('D DESPUES',D)
    # print('D_final DESPUES',D_final)
    # print('D_betados DESPUES',D_betados)

    tiempo_total_final = 0
    for vl in D_final.keys():
      tiempo_total_final += max(0, (D_final[vl] - (D_inicial[vl] +deadline)))
      # print('Tiempo de demora del cliente:', vl, 'es:', max(0, (D_final[vl] - (D_inicial[vl] +deadline))))

    T.append(tiempo_total_final)
    # print('tiempo_total_final', tiempo_total_final)

  buffer.append(sum(T)/len(T))
  # print('El promedio de atraso de los escenarios, dado un buffer de', b,'es:', sum(T)/len(T))
    #print(Theta)
    #if es == 1:
    # break
buffer_opt = buffer.index(min(buffer))
print('El buffer optimo fue:', buffer_opt, 'y entregó un atraso de:', min(buffer))
print('Si el buffer fue 0, el atraso fue de:',buffer[0])

!pip uninstall matplotlib
!pip install matplotlib==3.1.3



plt.plot(buffer)
plt.show()